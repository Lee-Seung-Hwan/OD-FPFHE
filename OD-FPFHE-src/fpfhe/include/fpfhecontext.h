/*************
 * This file is modified from binfhecontext.h which is writen by Leo Ducas and Daniele Micciancio.
 * Full paper is listed in : eprint.iacr.org/2022/186.
 * This source is obeyed and applied following copyright law. 
 *
 * If you have any question, please contact us by the email kr3951@hanyang.ac.kr
 * Seunghwan Lee, 2022.03.04
 * *************/


// @file binfhecontext.h - Header file for BinFHEContext class, which is used
// for Boolean circuit FHE schemes
//
// @author TPOC: contact@palisade-crypto.org
// @copyright Copyright (c) 2019, Duality Technologies Inc.
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution. THIS SOFTWARE IS
// PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef FPFHE_FHECONTEXT_H
#define FPFHE_FHECONTEXT_H

#include <memory>
#include <string>

#include "fpfhew.h"
#include "fplwe.h"
#include "fprlwe.h"
#include "fpringcore.h"

#include "utils/serializable.h"

namespace lbcrypto {

// security levels for predefined parameter sets
enum FPFHEPARAMSET {
  FPFHE,      // Testing Paramsets
	TOY,        // no security
  MEDIUM,     // 108 bits of security for classical and 100 bits for quantum
  STD128D,     // more than 128 bits of security for classical
  STD128S,     // more than 128 bits of security for classical
  STD160D,     // more than 168 bits of security for classical
  STD160S,     // more than 168 bits of security for classical
  STD192D,     // more than 168 bits of security for classical
  STD192S,     // more than 168 bits of security for classical
  STD128S_2,     // more than 128 bits of security for classical
  STD128H_1,     // more than 128 bits of security for classical
  STD128H_2,     // more than 128 bits of security for classical
 



	//STD128,     // more than 128 bits of security for classical
              // computer attacks - uses the same setup as HE standard
  STD128_AP,  // Optimized for AP (has higher failure probability for GINX) -
              // more than 128 bits of security for classical computer attacks -
              // uses the same setup as HE standard
  STD192,     // more than 192 bits of security for classical computer attacks -
              // uses the same setup as HE standard
  STD256,     // more than 256 bits of security for classical computer attacks -
              // uses the same setup as HE standard
  STD128Q,    // more than 128 bits of security for quantum attacks - uses the
              // same setup as HE standard
  STD192Q,    // more than 192 bits of security for quantum attacks - uses the
              // same setup as HE standard
  STD256Q,    // more than 256 bits of security for quantum attacks - uses the
              // same setup as HE standard
  SIGNED_MOD_TEST  // special parameter set for confirming the signed modular
                   // reduction in the accumulator updates works correctly
};

// Type of ciphertext generated by the Encrypt method
enum FPFHEOUTPUT {
  FRESH,        // a fresh encryption
  BOOTSTRAPPED  // a freshly encrypted ciphertext is bootstrapped
};

class FPLWECiphertextImpl;

using FPLWECiphertext = std::shared_ptr<FPLWECiphertextImpl>;
using FPConstLWECiphertext = const std::shared_ptr<const FPLWECiphertextImpl>;

class FPLWEPrivateKeyImpl;
using FPLWEPrivateKey = std::shared_ptr<FPLWEPrivateKeyImpl>;
using FPConstLWEPrivateKey = const std::shared_ptr<const FPLWEPrivateKeyImpl>;

// Mimic
class FPRLWECiphertextImpl;
using FPRLWECiphertext = std::shared_ptr<FPRLWECiphertextImpl>;
using FPConstRLWECiphertext = const std::shared_ptr<const FPRLWECiphertextImpl>;

class FPRLWEPrivateKeyImpl;
using FPRLWEPrivateKey = std::shared_ptr<FPRLWEPrivateKeyImpl>;
using FPConstRLWEPrivateKey = const std::shared_ptr<const FPRLWEPrivateKeyImpl>;


/**
 * @brief FPFHEContext
 *
 * The wrapper class for Boolean circuit FHE
 */
class FPFHEContext : public Serializable {
 public:
  FPFHEContext() {}

  /**
   * Creates a crypto context using custom parameters.
   * Should be used with care (only for advanced users familiar with LWE
   * parameter selection).
   *
   * @param n lattice parameter for additive LWE scheme
   * @param N ring dimension for RingGSW/RLWE used in bootstrapping
   * @param &q modulus for additive LWE
   * @param &Q modulus for RingGSW/RLWE used in bootstrapping
   * @param std standard deviation
   * @param baseKS the base used for key switching
   * @param baseG the gadget base used in bootstrapping
   * @param baseR the base used for refreshing
   * @param method the bootstrapping method (AP or GINX)
   * @return creates the cryptocontext
   */
  void GenerateFHEContext(uint32_t n, uint32_t N, const uint32_t Packing_N, const NativeInteger &q,
                             const NativeInteger &Q, double std, double r_std,
														 double gsw_std,
                             uint32_t baseKS, uint32_t scaling, uint32_t baseC,  uint32_t baseG, uint32_t baseR, uint32_t GD_base,
                             FPFHEMETHOD method = GINX);

  /**
   * Creates a crypto context using predefined parameters sets. Recommended for
   * most users.
   *
   * @param set the parameter set: TOY, MEDIUM, STD128, STD192, STD256
   * @param method the bootstrapping method (AP or GINX)
   * @return create the cryptocontext
   */
  void GenerateFHEContext(FPFHEPARAMSET set, bool Parallels=true);

  /**
   * Gets the refreshing key (used for serialization).
   *
   * @return a shared pointer to the refreshing key
   */
  const std::shared_ptr<FPRingGSWBTKey> GetRefreshKey() const {
    return m_BTKey->BSkey;
  }

	void CheckQ(uint32_t bits, uint32_t nums, vector<NativeInteger> *muls_odd, vector<uint32_t> *bits_arr, vector<uint32_t> *res_bit_arr) const;

  /**
   * Gets the switching key (used for serialization).
   *
   * @return a shared pointer to the switching key
   */
  const std::shared_ptr<FPLWESwitchingKey> GetSwitchKey() const {
    return m_BTKey->PKSkey;
  }

  /**
   * Generates a secret key for the main LWE scheme
   *
   * @return a shared pointer to the secret key
   */
  FPLWEPrivateKey KeyGen() const;

  /**
   * Generates a secret key used in bootstrapping
   * @return a shared pointer to the secret key
   */
  FPLWEPrivateKey KeyGenN() const;


	/* RLWE Key Gen */
	FPRLWEPrivateKey RKeyGen() const;

  /**
   * Encrypts a bit using a secret key (symmetric key encryption)
   *
   * @param sk - the secret key
   * @param &m - the plaintext
   * @param output - FRESH to generate fresh ciphertext, BOOTSTRAPPED to
   * generate a refreshed ciphertext (default)
   * @return a shared pointer to the ciphertext
   */
  FPLWECiphertext Encrypt(FPConstLWEPrivateKey sk, const FPLWEPlaintext &m,
                        FPFHEOUTPUT output = BOOTSTRAPPED) const;

	
	FPConstRLWECiphertext REncrypt(FPConstRLWEPrivateKey sk, DCRTPoly &m
														) const;

	
	void DivideRounding(DCRTPoly *double_poly, DCRTPoly *out_poly, Format format) const;
	DCRTPoly DivideRounding(DCRTPoly *double_poly, Format format) const;
	void SGDLevel2(DCRTPoly *in_poly, vector<DCRTPoly> *out_poly, uint32_t bits, uint32_t rm_len, Format format);
	vector<DCRTPoly> SGDLevel2(const DCRTPoly &in_poly, uint32_t bits, uint32_t rm_len, Format format);
	void ProductDCRT(
			const vector<DCRTPoly> *A1, const DCRTPoly *b1, 
			const vector<DCRTPoly> *A2, const DCRTPoly *b2,
			vector<DCRTPoly> *outA,			DCRTPoly *outb);
	vector<DCRTPoly> ProductDCRT(
			const vector<DCRTPoly> *A1, const DCRTPoly *b1, 
			const vector<DCRTPoly> *A2, const DCRTPoly *b2);
		


	DCRTPoly EncodingUInt64(uint64_t m) const;
	DCRTPoly EncodingExp(uint64_t m) const;
	DCRTPoly EncodingSign(int64_t m) const;
	uint64_t DecodingUInt64(DCRTPoly poly) const;
	uint64_t DecodingInt64(DCRTPoly poly) const;
	uint64_t DecodingExp(DCRTPoly poly) const;
	
	DCRTPoly MakeDG() const;

	FPConstRLWECiphertext EncryptUInt64(FPConstRLWEPrivateKey sk, uint64_t &m) const;
		
	FPConstRLWECiphertext EncryptInt64(FPConstRLWEPrivateKey sk, int64_t &m) const;
	FPRLWECiphertext EncryptDouble(FPConstRLWEPrivateKey sk, double &m) const;
	FPRLWECiphertext EncryptFloat(FPConstRLWEPrivateKey sk, float &m) const;
	FPConstRLWECiphertext EncryptHalf(FPConstRLWEPrivateKey sk, float &m) const;
	
	
	uint64_t BSDecryptUInt64_TEST( 
										 FPConstRLWECiphertext ct,
										 const bool DIVIDE = false) const;


	uint64_t DecryptUInt64(FPConstRLWEPrivateKey sk, 
										 FPConstRLWECiphertext ct,
										 const bool DIVIDE = false) const;


	int64_t DecryptMulPoly(FPConstRLWEPrivateKey sk, 
											vector<DCRTPoly> cts,
										 const uint32_t mul_max,
										 const bool mul_flag= false,
										 const bool DIVIDE = false) const ;


	uint64_t DecryptCompensate(FPConstRLWEPrivateKey sk, 
											vector<DCRTPoly> cts,
										const bool DIVIDE = false) const ;





	int64_t DecryptInt64(FPConstRLWEPrivateKey sk, 
										 FPConstRLWECiphertext ct,
										 const bool DIVIDE = false);
	double DecryptDouble(FPConstRLWEPrivateKey sk, 
										 FPConstRLWECiphertext ct,
										 const bool DIVIDE = false) const;
	
	float DecryptFloat(FPConstRLWEPrivateKey sk, 
										 FPConstRLWECiphertext ct,
										 const bool DIVIDE = false) const;
	
	float DecryptHalf(FPConstRLWEPrivateKey sk, 
										 FPConstRLWECiphertext ct,
										 const bool DIVIDE = false) const;
	

	int64_t DecryptExp(FPConstRLWEPrivateKey sk, 
										 const vector<DCRTPoly> &cts) const;



	void Int2Double(uint64_t vals);
	void Double2Int(double vals);



	/**
   * Decrypts a ciphertext using a secret key
   *
   * @param sk the secret key
   * @param ct the ciphertext
   * @param *result plaintext result
   */
  void Decrypt(FPConstLWEPrivateKey sk, 
							 FPConstLWECiphertext ct,
               FPLWEPlaintext_double *result) const;
 
	void RDecrypt(FPConstRLWEPrivateKey sk, 
							 FPConstRLWECiphertext ct,
               DCRTPoly *result) const;


  /**
   * Generates a switching key to go from a secret key with (Q,N) to a secret
   * key with (q,n)
   *
   * @param sk new secret key
   * @param skN old secret key
   * @return a shared pointer to the switching key
   */
  std::shared_ptr<FPLWESwitchingKey> KeySwitchGen(FPConstLWEPrivateKey sk,
                                                FPConstLWEPrivateKey skN) const;

  /**
   * Generates boostrapping keys
   *
   * @param sk secret key
   */
  void BTKeyGen( FPConstRLWEPrivateKey skR);

	
	const std::shared_ptr<const FPRLWECiphertextImpl> DivideReduction(
		const std::shared_ptr<const FPRLWECiphertextImpl> ct) const;
			
  /**
   * Loads bootstrapping keys in the context (typically after deserializing)
   *
   * @param key struct with the bootstrapping keys
   */
  void BTKeyLoad(const FPRingGSWEvalKey &key) { *m_BTKey = key; }

  /**
   * Clear the bootstrapping keys in the current context
   */
  void ClearBTKeys() {
    m_BTKey->BSkey.reset();
    m_BTKey->PKSkey.reset();
  }

  /**
   * Evaluates a binary gate (calls bootstrapping as a subroutine)
   *
   * @param gate the gate; can be AND, OR, NAND, NOR, XOR, or XNOR
   * @param ct1 first ciphertext
   * @param ct2 second ciphertext
   * @return a shared pointer to the resulting ciphertext
   */
  FPLWECiphertext EvalBinGate(const FPGATE gate, FPConstLWECiphertext ct1,
                            FPConstLWECiphertext ct2) const;

  /**
   * Bootstraps a ciphertext (without peforming any operation)
   *
   * @param ct1 ciphertext to be bootstrapped
   * @return a shared pointer to the resulting ciphertext
   */
  FPRLWECiphertext Bootstrap(FPConstRLWECiphertext ct1) const;
  FPConstRLWECiphertext BootstrapOrign(FPConstRLWECiphertext ct1) const;

	uint64_t CheckDecryptBeforeBS(FPConstRLWEPrivateKey sk, FPConstRLWECiphertext ct, uint32_t idx) const;

  /**
   * Evaluates NOT gate
   *
   * @param ct1 the input ciphertext
   * @return a shared pointer to the resulting ciphertext
   */
  FPLWECiphertext EvalNOT(FPConstLWECiphertext ct1) const;


	std::shared_ptr<FPOFUF> MakeOverFlowDetectCT() const;
	void CheckOFUF( FPConstRLWEPrivateKey Rsk, shared_ptr<FPOFUF> ct_OFUF) const;


	// FPFHE gogo
	FPConstRLWECiphertext ProductUOrign( FPConstRLWECiphertext ct1,
														FPConstRLWECiphertext ct2) const;
	FPRLWECiphertext Product( FPConstRLWECiphertext ct1,
														FPConstRLWECiphertext ct2,
														//FPConstRLWEPrivateKey Rsk,
														//const FPOFUF &ct_OFUF 
														std::shared_ptr<FPOFUF> ct_OFUF
														) const;
	
	FPRLWECiphertext ProductDouble( FPConstRLWECiphertext ct1,
														FPConstRLWECiphertext ct2,
														//FPConstRLWEPrivateKey Rsk,
														//const FPOFUF &ct_OFUF
														std::shared_ptr<FPOFUF> ct_OFUF
														) const;
	
	FPConstRLWECiphertext ProductOnly( FPConstRLWECiphertext ct1,
														FPConstRLWECiphertext ct2) const;
	
	FPRLWECiphertext AddCore( FPConstRLWECiphertext ct1,
														FPConstRLWECiphertext ct2,
														//FPConstRLWEPrivateKey Rsk,
														//const FPOFUF &ct_OFUF,
														std::shared_ptr<FPOFUF> ct_OFUF,
														bool adding = true
														) const;
	
	
	FPRLWECiphertext AddCoreF( FPConstRLWECiphertext ct1,
														FPConstRLWECiphertext ct2,
														//FPConstRLWEPrivateKey Rsk,
														bool adding = true
														) const;
	
	FPRLWECiphertext AddCoreH( FPConstRLWECiphertext ct1,
														FPConstRLWECiphertext ct2,
														//FPConstRLWEPrivateKey Rsk,
														bool adding = true
														) const;
	



	FPRLWECiphertext Add( FPConstRLWECiphertext ct1,
														FPConstRLWECiphertext ct2,
														//FPConstRLWEPrivateKey Rsk,
														//const FPOFUF &ofuf
														std::shared_ptr<FPOFUF> ct_OFUF
														) const;
	FPRLWECiphertext Sub( FPConstRLWECiphertext ct1,
														FPConstRLWECiphertext ct2,
														//FPConstRLWEPrivateKey Rsk,
														//const FPOFUF &ofuf
														std::shared_ptr<FPOFUF> ct_OFUF
														) const;





	vector<DCRTPoly> Product_RD_Coeff( FPConstRLWECiphertext ct1,
														FPConstRLWECiphertext ct2) const;


	FPConstLWECiphertext SampleExtract( FPConstRLWECiphertext ct,
			uint32_t idx) const;

	std::shared_ptr<FPLWEPrivateKeyImpl> RLWEKey2LWEKey(FPRLWEPrivateKey sk_r) const;



	void CheckBS() const;
  
	void CheckKS(FPRLWEPrivateKey sk) const ;
	
	std::shared_ptr<FPRLWECiphertextImpl> BootstrapMul(
   const std::shared_ptr<const FPRLWECiphertextImpl> ct);
	
	std::shared_ptr<FPRLWECiphertextImpl> BootstrapAdd(
   const std::shared_ptr<const FPRLWECiphertextImpl> ct) const;



	const std::shared_ptr<FPRingGSWCryptoParams> GetParams() { 
		return m_params; 
	}

  const std::shared_ptr<FPLWEEncryptionScheme> GetLWEScheme() {
    return m_LWEscheme;
  }

  const std::shared_ptr<FPRingGSWAccumulatorScheme> GetRingGSWScheme() {
    return m_RingGSWscheme;
  }


  template <class Archive>
  void save(Archive &ar, std::uint32_t const version) const {
    ar(::cereal::make_nvp("params", m_params));
  }

  template <class Archive>
  void load(Archive &ar, std::uint32_t const version) {
    if (version > SerializedVersion()) {
      PALISADE_THROW(deserialize_error,
                     "serialized object version " + std::to_string(version) +
                         " is from a later version of the library");
    }
    ar(::cereal::make_nvp("params", m_params));
  }

  std::string SerializedObjectName() const { return "FPRingGSWBTKey"; }
  static uint32_t SerializedVersion() { return 1; }

  private:
  // Shared pointer to Ring GSW + LWE parameters
  std::shared_ptr<FPRingGSWCryptoParams> m_params;
	
  // Shared pointer to the underlying additive LWE scheme
  std::shared_ptr<FPLWEEncryptionScheme> m_LWEscheme;
	
	// Shared pointer to the underlying Ring LWE scheme
	std::shared_ptr<FPRLWEEncryptionScheme> m_RLWEscheme;

  // Shared pointer to the underlying RingGSW/RLWE scheme
  std::shared_ptr<FPRingGSWAccumulatorScheme> m_RingGSWscheme;

  // Struct containing the bootstrapping keys
	std::shared_ptr<FPRingGSWEvalKey> m_BTKey;
	

};
}  // namespace lbcrypto

#endif
